iterator.md

迭代器：簡單地說，迭代器是包含方法__next__的對象，可用於迭代一組值。

沒有更多的值可迭代時，方法__next__應引發StopIteration異常。

可迭代對象包含方法__iter__，它返回一個像序列一樣可用於for循環中的迭代器。

通常，迭代器也是可迭代的，即包含返回迭代器本身的方法__iter__。

iter(obj)        從可迭代對象創建一個迭代器，調用iter時，還可提供其他參數，詳見標準Python文檔

next(it)         讓迭代器前進一步並返回下一個元素

迭代器協議

迭代（iterate）意味著重複多次，就像循環那樣。可以使用for循環迭代過序列和字典，但實際上也可迭代其他對象：實現了方法__iter__的對象。

方法__iter__返回一個迭代器，它是包含方法__next__的對象，而調用這個方法時可不提供任何參數。當你調用方法__next__時，迭代器應返回其下一個值。如果迭代器沒有可供返回的值，應引發StopIteration異常。你還可使用內置的便利函數next，在這種情況下，next(it)與it.__next__()等效。

在Python3中，迭代器協議有細微的變化。在以前的迭代器協議中，要求迭代器對象包含方法next而不是__next__。

使用迭代器有什麼意義呢？為何不使用列表呢？因為在很多情況下，使用列表都有點像用大砲打蚊子。例如，如果你有一個可逐個計算值的函數，你可能只想逐個地獲取值，而不是使用列表一次性獲取。這是因為如果有很多值，列表節能佔用太多的內存。但還有其他原因：使用迭代器更通用、更簡單、更優雅。下面來看一個不能使用列表的示例，因為如果使用，這個列表的長度必須是無窮大的！

這個“列表”為斐波那契數列，表示該數列的迭代器如下：

class Fibs:
    def __init__(self):
        self.a = 0
        self.b = 1
    def __next__(self):
        self.a, self.b=self.b, self.a + self.b
        return self.a
    def __iter__(self):
        return self

注意到這個迭代器實現了方法__iter__，而這個方法返回迭代器本身。

在很多情況下，都在另一個對像中實現返回迭代器的方法__iter__，並在for循環中使用這個對象。

但推薦在迭代器中也實現方法__iter__（並像剛才那樣讓它返回self），這樣迭代器就可直接用於for循環中。

更正規的定義是，實現了方法__iter__的對像是可迭代的，而實現了方法__next__的對象的迭代器。

首先，創建一個Fibs對象。

>>>fibs = Fibs()

然後就可在for循環中使用這個對象，如找出第一個大於1000的斐波那契數。

>>>for f in fibs:
...    if f>1000:
...        print(f)
...        break
...
1597

這個循環之所以會停止，是因為其中包含break語句；否則，這個for循環將沒完沒了地執行。

通過對可迭代對象調用內置函數iter，可獲得一個迭代器。

>>>it = iter([1,2,3])
>>>next(it)
1
>>>next(it)
2
>>>next(it)
3
>>>next(it)
Traceback (most recent call last):
  File "<pyshell#58>", line 1, in <module>
    next(it)
StopIteration

還可使用它從函數或其他可調用對象創建可迭代對象，詳情請參閱庫參考手冊。