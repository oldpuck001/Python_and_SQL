

封裝：對象可能隱藏（封裝）其內部狀態。在有些語言中，這意味著對象的狀態（屬性）只能通過其方法來訪問。在Python中，所有的屬性都是公有的，但直接訪問對象的狀態時程序員應謹慎行事，因為這可能在不經意間導致狀態不一致。

封裝（encapsulation）指的是向外部隱藏不必要的細節。這聽起來有點像多態（無需知道對象的內部細節就可使用它）。這兩個概念很像，因為它們都是抽象的原則。它們都像函數一樣，可幫助你處理程序的組成部分，讓你無需關心不必要的細節。

但封裝不同於多態。多態讓你無需知道對象所屬的類（對象的類型）就能調用其方法，而封裝讓你無需知道對象的構造就能使用它。聽起來還是有點像？下面來看一個使用了多態但沒有使用封裝的示例。假設你有一個名為OpenObject的類。

>>>o = OpenObject()    #對象就是這樣創建的
>>>o.set_name('Sir Lancelot')
>>>o.get_name()
'Sir Lancelot'

你（通過像調用函數一樣調用類）創建了一個對象，並將其關聯到變量o，然後就可以使用方法set_name和get_name了（假設OpenObject支持這些方法）。一切都看起來完美無缺。然而，如果o將其名稱存儲在全局變量global_name中呢？ （我對這裡的理解是，在OpenObject中，使用了全局變量，即在函數內部使用global聲明全局變量）。

>>>global_name
'Sir Lancelot'

這意味著使用OpenObject類的實例（對象）時，你需要考慮global_name的內容。事實上，必須確保無人能修改它。

>>>global_name = 'Sir Gumby'
>>>o.get_name()
'Sir Gumby'

如果嘗試創建多個OpenObject對象，將出現問題，因為它們共用同一個變量。

>>>o1 = OpenObject()
>>>o2 = OpenObject()
>>>o1.set_name(‘Robin Hood')
>>>o2.get_name()
'Robin Hood'

如你所見，設置一個對象的名稱時，將自動設置另一個對象的名稱。這可不是你想要的結果。

基本上，你希望對像是抽象的：當調用方法時，無需操心其他的事情，如避免干擾全局變量。

將名稱“封裝”在對像中的方法：將其作為一個屬性即可。

屬性是歸屬於對象的變量，就像方法一樣。實際上，方法差不多就是與函數相關聯的屬性。如果你使用屬性而非全局變量重新編寫前面的類，並將其重命名為ClosedObject，就可像下面這樣使用它：

>>>c = ClosedObject()
>>>c.set_name(‘Sir Lancelot')
>>>c.get_name()
‘Sir Lancelot'

到目前為止一切順利，但這並不能證明名稱不是存儲在全局變量中的。下面再來創建一個對象。

>>>r = ClosedObject()
>>>r.set_name(‘Sir Robin')
>>>r.get_name()
'Sir Robin'

從中可知正確地設置了新對象的名稱（這可能在你的意料之中），但第一個對象現在怎麼樣了呢？

>>>c.get_name()
'Sir Lancelot’

其名稱還在！因為這個對像有自己的狀態。對象的狀態由其屬性（如名稱）描述。對象的方法可能修改這些屬性，因此對象將一系列函數（方法）組合起來，並賦予它們訪問一些變量（屬性）的權限，而屬性可用於在兩次函數調用之間存儲值。

（我的理解，因為有了封裝，所以兩個對象使用同一個函數時，才不會互相干擾對方的值）