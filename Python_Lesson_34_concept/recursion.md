recursion.md

函數可調用自身，這稱為遞歸。

可使用遞歸完成的任何任務都可使用循環來完成，但有時使用遞歸函數的可讀性更高。

簡單地說，遞歸意味著引用（這裡是調用）自身。下面是一個遞歸式函數定義：

def recursion():
    return recursion()

如果你運行它，結果將如何呢？你將發現運行一段時間後，這個程序崩潰了（引發異常）。從理論上說，這個程序將不斷運行下去，但每次調用函數時，都將消耗一些內存。因此函數調用次數達到一定的程度（且之前的函數調用未返回）後，將耗盡所有的內存空間，導致程序終止並顯示錯誤消息“超過最大遞歸深度”。

這個函數中的遞歸稱為無窮遞歸（就像以while True打頭且不包含break和return語句的循環被稱為無限循環一樣），因為它從理論上說永遠不會結束。你想要的是能對你有所幫助的遞歸函數，這樣的遞歸函數通常包含下面兩部分。

基線條件（針對最小的問題）：滿足這種條件時函數將直接返回一個值。
遞歸條件：包含一個或多個調用，這些調用旨在解決問題的一部分。

這裡的關鍵是，通過將問題分解為較小的部分，可避免遞歸沒完沒了，因為問題終將被分解成基線條件可以解決的最小問題。

那麼如何讓函數調用自身呢？這沒有看起來那麼難懂。前面說過，每次調用函數時，都將為此創建一個新的命名空間。這意味著函數調用自身時，是兩個不同的函數［更準確地說，是不同版本（即命名空間不同）的同一個函數］在交流。你可將此視為兩個屬於相同物種的動物在彼此交流。

那麼使用遞歸有何意義呢？難道不能轉而使用循環嗎？答案是肯定的，而且在大多數情況下，使用循環的效率可能更高。然而，在很多情況下，使用遞歸的可讀性更高，且有時要高得多，在你理解了函數的遞歸式定義時尤其如此。另外，雖然你完全能夠避免編寫遞歸函數，但作為程序員，你必須能夠讀懂其他人編寫的遞歸算法和函數。