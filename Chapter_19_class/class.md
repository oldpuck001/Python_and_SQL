class.md

創建自定義類：class語句

類的屬性、函數和方法

函數和方法的區別表現在參數self上。

在Python中，方法（Method）和函數（Function）都是可調用對象，二者的作用相似但是有一些不同點：

1. 對象：方法是一個屬於對象的函數，而函數則是一個獨立的代碼塊。
2. 參數：方法的第一個參數是self，它表示對象本身，而函數沒有這個參數。
3. 調用方式：方法是通過對象進行調用，而函數則是直接調用。

類中的函數通常被稱為方法，因為它們屬於類，與其他函數的用途和實現方法有所不同。

方法（更準確地說是關聯的方法）將其第一個參數關聯到它所屬的實例，因此無需提供這個參數。

在class語句中定義的代碼都是在一個特殊的命名空間（類的命名空間）內執行的，而類的所有成員都可訪問這個命名空間。

類定義其實就是要執行的代碼段，並非所有的Python程序員都知道這一點，但知道這一點很有幫助。例如，在類定義中，並非只能包含def語句。

在類作用域內定義一個變量，所有的成員（實例）都可訪問它，例如定義一個用來計算類實例數量的變量。

每個實例都可以訪問這個類作用域內的變量，如果在一個實例中給類的屬性賦值，新值將被寫入屬性中，這個屬性遮住了類級變量。

要指定超類，可在class語句中的類名後加上超類名，並將其用圓括號括起。
子類從超類那裡直接繼承了方法和定義等。
多重繼承是一個功能強大的工具。然而，除非萬不得已，否則應避免使用多重繼承，因為在有些情況下，它可能帶來意外的“並發症”。
使用多重繼承時，如果多個超類以不同的方式實現了同一個方法（即有多個同名方法），必須在class語句中小心排列這些超類，因為位於前面的類的方法將覆蓋位於後面的類的方法。
多個超類的超類相同時，查找特定方法或屬性時訪問超類的順序稱為方法解析順序（MRO），它使用的算法非常複雜。所幸其效果很好，你可能根本無需擔心。

在Python中，超類（super class）和基類（base class）基本上是同一個概念，兩者都指的是被其他類繼承的類。不同的說法主要是用於描述的角度略有不同：
 1. 基類（Base Class）：
 • 更強調它是「基礎」，是用來構建其他類的基礎類別。
 • 是一個相對靜態的描述，指某個類在繼承結構中的位置。
 2. 超類（Super class）：
 • 更強調它是「上層」，相對於某個子類來說，表示它是子類的上層類。
 • 通常用來從動態的角度描述某類的繼承來源。

重寫普通方法和特殊的構造函數
每個類都有一個或多個超類，並從它們那裡繼承行為。對子類的實例調用方法（或訪問其屬性）時，如果找不到該方法（或屬性），將在其超超類中查找。
要在子類中添加功能，一種基本方式是添加方法。在子类中重寫超類的某些方法，可以定制繼承而來的行為。重寫是繼承機制的一個重要方面。

構造函數用於初始化新建對象的狀態，而對大多數子類來說，除超類的初始化代碼外，還需要有自己的初始化代碼。雖然所有方法的重寫機制都相同，但與重寫普通方法相比，重寫構造函數時更有可能遇到一個特別的問題：重寫構造函數時，必須調用超類（繼承的類）的構造函數，否則可能無法正確地初始化對象。要消除這種錯誤，子類的構造函數必須調用其超類的構造函數，以確保基本的初始化得以執行。為此，可以使用函數super。

子類構造函數調用其超類的構造函數：使用函數super

super(class,obj)        返回一個超類的關聯實例，調用時，還可提供其他參數，詳見標準Python文檔

調用這個函數時，將當前類和當前實例作為參數。對其返回的對象調用方法時，調用的將是超類（而不是當前類）的方法。另外，可像通常那樣（也就是像調用關聯的方法那樣）調用方法__init__。

在Python3中調用函數super時，可不提供任何參數（通常也不應該這樣做），而它將像變魔術一樣完成任務。

super().__init__()