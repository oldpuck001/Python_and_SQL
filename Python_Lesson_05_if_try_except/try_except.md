try_except.md

在很多情況下，相比於使用if/else，使用try/except語句更自然，也更符合Python的風格。因此應養成盡可能使用try/except語句的習慣。

異常比較有趣的地方是可對其進行處理，通常稱之為捕獲異常。為此，可使用try/except語句捕獲異常。

except子句：要捕獲異常，可在try語句中使用except子句。在except子句中，如果沒有指定異常類，將捕獲所有的異常。你可指定多個異常類，方法是將它們放在元組中。如果向except提供兩個參數，第二個參數將關聯到異常對象（as）。在同一條try/except語句中，可包含多個except子句，以便對不同的異常採取不同的措施。

else子句：除except子句外，還可使用else子句，它在主try塊沒有引發異常時執行。

finally子句：要確保代碼快（如清理代碼）無論是否引發異常都將執行，可使用try/except，並將代碼塊放在finally子句中。

異常從函數向外傳播到調用函數的地方。如果在這裡也沒有被捕獲，異常將向程序的最頂層傳播。這意味著你可使用try/except來捕獲他人所編寫的函數引發的異常。有關這方面的詳細信息，參見異常和函數。

try:
    # 可能出現異常的代碼

except ExceptionType1:
    # 異常處理代碼1

except ExceptionType2:
    # 異常處理代碼2

except:
    # 異常處理代碼3（捕捉所有異常）

else:
    # 當沒有異常發生時執行的代碼

finally:
    # 無論有沒有異常發生都會執行的代碼

一些內置的異常類
類名                     描述
Exception               几乎所有的异常类都是从它派生而来的
AttributeError          引用属性或给它赋值失败时引发
OSError                 操作系统不能执行指定的任务(如打开文件)时引发，有多个子类
IndexError              使用序列中不存在的索引时引发，为LookupError的子类
KeyError                使用映射中不存在的键时引发，为LookupError的子类
NameError               找不到名称（变量）时引发
SyntaxError             代码不正确时引发
TypeError               将内置操作或函数用于类型不正确的对象时引发
ValueError              将内置操作或函数用于这样的对象时引发：其类型正确但包含的值不合适
ZeroDivisionError       在除法或求模运算的第二个参数为零时引发

棧跟蹤（Stack Trace）是指當Python程序遇到異常時，系統會自動記錄下程序當前的狀態，包括異常發生時的當前位置、函數調用的層次、當前調用堆棧等信息，以方便開發者排查問題。
當Python程序遇到異常時，通常會顯示出一個錯誤信息，其中包括異常的類型、描述信息和棧跟蹤。棧跟蹤通常是一個由多行文字組成的報錯信息，其中包括異常發生的位置、異常類型、異常描述信息，以及導致異常的函數調用堆棧等信息。透過這些信息，開發者可以快速定位到出錯的位置和原因，進行調試和修復。