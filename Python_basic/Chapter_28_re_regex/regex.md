regex.md

正則表達式基本語法規則總結：

注意，在這裡，術語匹配指的是與整個字符串匹配，而函數match只要求模式與字符串開頭匹配。

1.字符匹配
正則表達式可與多個字符串匹配，你可使用特殊字符來創建這種正則表達式。（用 \ 来对字符进行转义）
.：句點與除換行符外的任何字符都匹配，因此被稱為通配符（wildcard）。句點只與一個字符匹配，而不與零或多個字符匹配。


2.自定義字符集
可以用方括號將一個子串括起，創建一個所謂的自定義字符集。這樣的字符集與其包含的字符都匹配。
字符集只能匹配一個字符，例如：‘[pj]ython’與’python’和’jython’都匹配，但不與其他字符串匹配。
字符集中的特殊字符（如果要將其用作字面字符而不是正則表達式，必須使用反斜槓對其進行轉義）：
脱字符（^）位於字符集開頭時，除非要將其用作排除運算符，否則必須對其進行轉義。換而言之，除非有意為之，否則不要將其放在字符集開頭。脱字符（^）的效果将作用于给定字母集合里所有字符或字符区间，而不是仅限于紧跟在脱字符（^）后面的那一个字符或字符区间。
對於右方括號（]）和連字符（-），要麼將其放在字符集開頭，要麼使用反斜槓對其進行轉義。實際上，如果你願意，也可將連字符放在字符集末尾。
一般而言，對於諸如句點、星號和問號等特殊字符，要在模式中將其用作字面字符而不是正則表達式，必須使用反斜槓對其進行轉義。在字符集中，通常無須對這些字符進行轉義，但進行轉義也是完全合法的。注意，對特殊字符進行時，使用兩個反斜槓（解釋器執行的轉義和模塊re執行的轉義），在自定義字符集中，使用一個反斜槓。
举例及常用字符集：
[abc]：匹配方括號內的任何字符，例如a、b或c。
[^abc]：要指定排除字符集，可在開頭添加一個^字符，匹配不在方括號內的任何字符，與除a、b和c外的其他任何字符都匹配。
[a-z]：這個字符集使用了範圍，與a~z的任何字母都匹配。
[a-zA-Z0-9]：這個字符集組合了多個訪問，方法是依次列出它們，與大寫字母、小寫字母和數字都匹配。

3.對特殊字符進行轉義與預設字符集
普通字符只與自己匹配，但特殊字符的情況完全不同。例如，假設要匹配字符串'python.org'，可以直接使用模式'python.org'嗎？可以，但它也與'pythonzorg'匹配（句點與除換行符外的其他字符都匹配），這可能不是你想要的結果。
要讓特殊字符的行為與普通字符一樣，可對其進行轉義：像對字符串中的引號進行轉義時所做的那樣，在它前面加上一個反斜槓。因此，在這個示例中，可使用模式'python\\.org'，它只與'python.org'匹配。
請注意，為表示模塊re要求的單個反斜槓，需要在字符串中書寫兩個反斜槓，讓解釋器對其進行轉義。換而言之，這裡包含兩層轉義：解釋器執行的轉義和模塊re執行的轉義。實際上，在有些情況下也可使用單個反斜槓，讓解釋器自動對其進行轉義，但請不要這樣依賴解釋器。如果你厭倦了兩個反斜槓，可使用原始字符串，如r'python\.org'。
常用轉義：
\w：匹配任何字母、數字或下劃線字符，相當於[a-zA-Z0-9_]
\W：匹配任何非字母、數字或下劃線字符，相當於[^a-zA-Z0-9_]
\d：匹配任何數字字符，相當於[0-9]
\D：匹配任何非數字字符，相當於[^0-9]
\s：匹配任何空白字符，包括空格、制表符、換行符等。
\S：匹配任何非空白字符。


4.可選模式和重複模式
*：匹配前面的字符或子模式0次或多次。
?：匹配前面的字符或子模式0次或1次。
+：匹配前面的字符或子模式1次或多次。
{m}：匹配前面的字符或子模式正好m次。
{m,}：匹配前面的字符或子模式至少m次。
{m,n}：匹配前面的字符或子模式至少m次，最多n次。


5.貪婪模式和非貪婪模式
貪婪模式：重複運算符默認是貪婪的，這意味著他們將匹配盡可能多的內容。例如如下模式：
emphasis_pattern=r'\*(.+)\*'
這個模式與以星號打頭和結尾的內容匹配。
>>>re.sub(emphasis_pattern,r'<em>\1</em>','*This* is *it*!')
'<em>This* is *it</em>!'
這個模式匹配了從第一個星號到最後一個星號的全部內容，其中包含另外兩個星號。這就是貪婪模式的意思：能匹配多少就匹配多少。
非貪婪模式：對於所有的重複運算符，都可在後面加上問號來將其指定為非貪婪的。例如：
>>>emphasis_pattern=r'\*\*(.+?)\*\*'
>>>re.sub(emphasis_pattern,r'<em>\1</em>','**This** is **it**!')
'<em>This</em> is <em>it</em>!'
這裡使用的是運算符+?而不是+，這個模式將匹配一個或多個通配符，但匹配盡可能少的內容，因為它是非貪婪的。因此，這個模式只匹配到下一個'\*\*'，即它末尾的內容。


6.匹配單詞/非單詞邊界
\b：匹配單詞邊界。
\B：匹配非單詞邊界。


7.字符串的開頭和末尾
^：匹配字符串的開始。
$：匹配字符串的結束。


8.二選一和子模式
 |：管道字符，匹配|兩邊的模式之一。例如：'python|perl'匹配字符串'python'和'perl'
子模式：如果不想將二選一運算符用於整個模式，只想將其用於模式的一部分。為此，可將這部分（子模式）放在圓括號內。對於前面的示例，可重寫為'p(ython|erl)'。請注意，單個字符也可稱為子模式。


9.回溯引用
回溯引用指的是模式的后半部分引用在前半部分中定义的子表达式。
Python的方式：返回一个包含着一个名为group的数组的匹配对象。


10.前查找（Lookahead）、後查找（Lookbehind）與組合使用
前查找用於匹配某個模式，並確保後面緊跟著另一個特定模式，但後面的模式不會包含在匹配結果中。
語法：
 • 肯定前查找：(?=...)
 • 否定前查找：(?!...)
範例：
import re
# 肯定前查找
text = 'hello world, hello python'
result = re.findall(r'hello(?=world)', text)
print(result)  # 輸出 ['hello']
# 否定前查找
result = re.findall(r'hello(?!world)', text)
print(result)  # 輸出 ['hello']

後查找用於匹配某個模式，並確保它前面有另一個特定模式，但前面的模式不會包含在匹配結果中。
後查找的長度限制：Python的正則表達式後查找模式（(?<=...) 和 (?<!...)）必須是固定長度，不能使用可變長度的表達式（例如 * 或 +）。
語法：
 • 肯定後查找：(?<=...)
 • 否定後查找：(?<!...)
範例：
import re
# 肯定後查找
text = 'world hello, python hello'
result = re.findall(r'(?<=world)hello', text)
print(result)  # 輸出 ['hello']
# 否定後查找
result = re.findall(r'(?<!world)hello', text)
print(result)  # 輸出 ['hello']

可以同時使用前查找和後查找，實現匹配模式兩側的條件限制。
範例：
import re
text = "apple pie, apple tart, banana pie"
# 匹配'apple'，要求前面是'banana'，後面是'pie'
result = re.findall(r"(?<=banana)apple(?= pie)", text)
print(result)  # 輸出 []


11.潛入條件
Python的正則表達式模組re支持嵌入條件，但其使用範圍有限。嵌入條件通常用於根據前面的分組是否匹配來決定後續的匹配行為。
嵌入條件僅能根據捕獲分組是否匹配來進行條件分支，無法直接嵌套過於複雜的邏輯。
嵌入條件的語法
(?(id)yes-pattern|no-pattern)
 • id 是捕獲分組的編號或名稱。
 • yes-pattern 是在該分組匹配時要匹配的模式。
 • no-pattern 是在該分組不匹配時要匹配的模式（可選）。
範例 1：根據捕獲分組條件匹配
import re
# 根據分組是否匹配來決定後續的匹配
pattern = r'(a)?(?(1)b|c)'
# 如果'a'匹配，後續匹配'b'
print(re.fullmatch(pattern, 'ab'))  # 輸出 <re.Match object; span=(0, 2), match='ab'>
# 如果'a'不匹配，後續匹配'c'
print(re.fullmatch(pattern, 'c'))   # 輸出 <re.Match object; span=(0, 1), match='c'>
範例 2：根據命名分組條件匹配
import re
# 使用命名分組的條件匹配
pattern = r'(?P<first>a)?(?(first)b|c)'
# 如果'first'分組匹配，後續匹配'b'
print(re.fullmatch(pattern, 'ab'))  # 輸出 <re.Match object; span=(0, 2), match='ab'>
# 如果'first'分組不匹配，後續匹配'c'
print(re.fullmatch(pattern, 'c'))   # 輸出 <re.Match object; span=(0, 1), match='c'>
無嵌入條件的替代方法
如果嵌入條件不夠靈活，可以考慮使用Python的邏輯結構配合re模組來實現。例如：
import re
# 動態構造正則模式
text = 'ab'
if 'a' in text:
    pattern = r'ab'
else:
    pattern = r'c'
print(re.fullmatch(pattern, text))  # 輸出 <re.Match object; span=(0, 2), match='ab'>